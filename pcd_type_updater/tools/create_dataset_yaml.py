import subprocess
import json
import yaml
import argparse
from typing import List, Dict, Any, Optional
from datetime import datetime

def run_subprocess(command: str) -> str:
    """
    Run a subprocess command and capture its output.

    Args:
        command (str): The command to run.

    Returns:
        str: The output from the subprocess command.
    """
    result: subprocess.CompletedProcess = subprocess.run(command, capture_output=True, text=True, shell=True)
    if result.returncode != 0 or result.stdout == '':
        print(f"Command failed with return code {result.returncode}")
        print(f"stderr: {result.stderr}")
        raise subprocess.CalledProcessError(result.returncode, command)
    return result.stdout

def parse_json_to_yaml(json_output: str, project_id: str, keyword: str) -> str:
    """
    Parse JSON output and convert it to a YAML format.

    Args:
        json_output (str): The JSON output to parse.
        project_id (str): The project ID to include in the YAML.
        keyword (str): The keyword used in the command, to be included in the YAML comment.

    Returns:
        str: The YAML formatted string.
    """
    data: Dict[str, Any] = json.loads(json_output)
    if not isinstance(data, dict) or 'annotation_datasets' not in data:
        raise ValueError("Expected JSON output to be a dictionary with an 'annotation_datasets' key")
    
    results: List[Dict[str, Any]] = data['annotation_datasets']
    t4dataset_ids: List[str] = [f"- {item['id']} # {item['name']}" for item in results]
    
    # Get the current date and time
    generated_at: str = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')
    
    # Construct YAML manually to match the required format
    return (
        f"# This file is automatically generated\n"
        f"# Command: webauto data annotation-dataset search --project-id {project_id} --name-keyword {keyword} --page-size 1000 --output json\n"
        f"# Generated at: {generated_at}\n"
        f"project_id: {project_id}\n"
        f"t4dataset_ids:\n" + "\n".join(t4dataset_ids)
    )

def create_dataset_yaml(project_id: str, keyword: str, output_dir: str, yaml_name: str) -> None:
    """
    Create a dataset YAML file based on the given project ID and keyword.

    Args:
        project_id (str): The project ID to use in the command.
        keyword (str): The keyword to search for in the command.
        output_dir (str): The directory where the output YAML file will be saved.
        yaml_name (str): The name of the output YAML file.
    """
    command: str = f"webauto data annotation-dataset search --project-id {project_id} --name-keyword {keyword} --page-size 100 --output json"
    json_output: str = run_subprocess(command)
    yaml_output: str = parse_json_to_yaml(json_output, project_id, keyword)
    
    output_path: str = f"{output_dir}/{yaml_name}"
    with open(output_path, "w") as yaml_file:
        yaml_file.write(yaml_output)

def main() -> None:

    parser: argparse.ArgumentParser = argparse.ArgumentParser(description="Create a dataset YAML file from JSON output.")
    parser.add_argument("--project-id", required=True, type=str, help="The project ID to use in the command.")
    parser.add_argument("--keyword", required=True, type=str, help="The keyword to search for in the command.")
    parser.add_argument("--output-dir", required=True, type=str, help="The directory where the output YAML file will be saved.")
    parser.add_argument("--yaml-name", required=True, type=str, help="The name of output YAML.")

    args: argparse.Namespace = parser.parse_args()

    create_dataset_yaml(args.project_id, args.keyword, args.output_dir, args.yaml_name)

if __name__ == "__main__":
    main()
